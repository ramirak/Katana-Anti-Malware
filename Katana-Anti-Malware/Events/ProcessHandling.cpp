#include "ProcessHandling.h"


void ProcDo(int procId, std::wstring procName, std::wstring procPath)
{
	string procName_a = wStringToString(procName);
	string procPath_a = wStringToString(procPath);
	std::map<string, vector<string>> &map = GetList();

	if (!map.size())
		// Whitelist process was never initiated, abort.
		return;
	try
	{
		switch (GetMode())
		{
			case SAFE_MODE:
			{
				{
					std::lock_guard lg(m);
					auto it1 = map.find(procName_a);

					if (it1 != map.end()) {
						// The process was found in our whitelist, check if path exists too.
						auto v = it1->second;
						
						if (std::find(v.begin(), v.end(), procPath_a) != v.end())
						{
							// The corresponding path was found, the process is safe.
							// No need to continue.
							return;
						}
					}
				}
				// Process was never whitelisted, consider unsafe and kill.
				const auto proc = OpenProcess(PROCESS_TERMINATE, false, procId);
				TerminateProcess(proc, 1);
				CloseHandle(proc);
				break;
			}
			case TRAINING_MODE:
			{
				std::lock_guard lg(m);
				auto it1 = map.find(procName_a);
				// Check if process name already exists, add if not.
				if (it1 == map.end()) {
					cout << "test" << endl;
					vector<string> vec;
					vec.push_back(procPath_a);
					map.insert(pair<string, vector<string>>(procName_a, vec));
				}
				else // Process name exists, check process path and add if not. 
				{
					auto v = it1->second;
					if (std::find(v.begin(), v.end(), procPath_a) == v.end())
					{
						v.push_back(procPath_a);
					}
				}
				break;
			}
			case ALLOW_MODE:
			{
				// Do nothing at the moment.
				break;
			}
			default:
				break;
		}
	}
	catch (const std::exception& ex)
	{
		cerr << ex.what() << endl;
		return;
	}
}

